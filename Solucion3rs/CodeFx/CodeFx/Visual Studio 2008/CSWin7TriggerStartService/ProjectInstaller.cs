/************************************** Module Header **************************************\
* Module Name:	ProjectInstaller.cs
* Project:		CSWin7TriggerStartService
* Copyright (c) Microsoft Corporation.
* 
* In ProjectInstaller, we configured the service to start when a generic USB disk becomes 
* available. It also shows how to trigger-start when the first IP address becomes available, 
* and trigger-stop when the last IP address becomes unavailable. 
* 
* This source is subject to the Microsoft Public License.
* See http://www.microsoft.com/opensource/licenses.mspx#Ms-PL.
* All other rights reserved.
* 
* History:
* * 8/1/2009 4:50 AM Jialiang Ge Created
\*******************************************************************************************/

#region Using directives
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration.Install;
using System.Linq;
using System.ServiceProcess;
using System.Runtime.InteropServices;
#endregion


namespace CSWin7TriggerStartService
{
    [RunInstaller(true)]
    public partial class ProjectInstaller : Installer
    {
        public ProjectInstaller()
        {
            InitializeComponent();
        }

        private void triggerStartServiceInstaller_AfterInstall(object sender, InstallEventArgs e)
        {
            // Service trigger events are not supported until Windows Server 2008 R2 and Windows 7
            // Windows Server 2008 R2 and Windows 7 have major version 6 and minor version 1
            if (Environment.OSVersion.Version >= new Version(6, 1))
            {
                Console.WriteLine("Configuring trigger-start service...");

                // Set the service to trigger-start when a generic USB disk becomes available.
                SetServiceTriggerStartOnUSBArrival(triggerStartServiceInstaller.ServiceName);

                // [-or-]

                // Set the service to trigger-start when the first IP address becomes available, 
                // and trigger-stop when the last IP address becomes unavailable.
                //SetServiceTriggerStartOnIPAddressArrival(triggerStartServiceInstaller.ServiceName);
            }
            else
            {
                Console.WriteLine("The current system does not support trigger-start service.");
            }
        }


        /// <summary>
        /// The GUID_DEVINTERFACE_DISK device interface class is defined for hard disk 
        /// storage devices.
        /// http://msdn.microsoft.com/en-us/library/bb663157.aspx
        /// </summary>
        private static readonly Guid GUID_DEVINTERFACE_DISK =
            new Guid("53F56307-B6BF-11D0-94F2-00A0C91EFB8B");

        /// <summary>
        /// Hardware ID generated by the USB storage port driver.
        /// </summary>
        private const string USBHardwareId = "USBSTOR\\GenDisk";


        /// <summary>
        /// The event is triggered when the first IP address on the TCP/IP networking stack 
        /// becomes available. 
        /// </summary>
        private static readonly Guid NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID =
            new Guid("4F27F2DE-14E2-430B-A549-7CD48CBC8245");

        /// <summary>
        /// The event is triggered when the last IP address on the TCP/IP networking stack 
        /// becomes unavailable.
        /// </summary>
        private static readonly Guid NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID =
            new Guid("CC4BA62A-162E-4648-847A-B6BDF993E335");


        /// <summary>
        /// Set the service to trigger-start when a generic USB disk becomes available.
        /// </summary>
        /// <param name="serviceName"></param>
        private void SetServiceTriggerStartOnUSBArrival(string serviceName)
        {
            using (ServiceController sc = new ServiceController(serviceName))
            {
                // Marshal Guid struct GUID_DEVINTERFACE_DISK to native memory
                IntPtr pGuidUSBDevice = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Guid)));
                Marshal.StructureToPtr(GUID_DEVINTERFACE_DISK, pGuidUSBDevice, false);

                // Allocate and set the SERVICE_TRIGGER_SPECIFIC_DATA_ITEM structure
                SERVICE_TRIGGER_SPECIFIC_DATA_ITEM deviceData;
                deviceData.dwDataType = ServiceTriggerDataType.SERVICE_TRIGGER_DATA_TYPE_STRING;
                deviceData.cbData = (uint)(USBHardwareId.Length + 1) * 2;
                IntPtr pUSBHardwareId = Marshal.StringToHGlobalUni(USBHardwareId);
                deviceData.pData = pUSBHardwareId;
                // Marshal the SERVICE_TRIGGER_SPECIFIC_DATA_ITEM struct to native memory
                IntPtr pDeviceData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(
                    SERVICE_TRIGGER_SPECIFIC_DATA_ITEM)));
                Marshal.StructureToPtr(deviceData, pDeviceData, false);

                // Allocate and set the SERVICE_TRIGGER structure
                SERVICE_TRIGGER serviceTrigger;
                serviceTrigger.dwTriggerType =
                    ServiceTriggerType.SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL;
                serviceTrigger.dwAction =
                    ServiceTriggerAction.SERVICE_TRIGGER_ACTION_SERVICE_START;
                serviceTrigger.pTriggerSubtype = pGuidUSBDevice;
                serviceTrigger.cDataItems = 1;
                serviceTrigger.pDataItems = pDeviceData;
                // Marshal the SERVICE_TRIGGER struct to native memory
                IntPtr pServiceTrigger = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(
                    SERVICE_TRIGGER)));
                Marshal.StructureToPtr(serviceTrigger, pServiceTrigger, false);

                // Allocate and set the SERVICE_TRIGGER_INFO structure. 
                SERVICE_TRIGGER_INFO serviceTriggerInfo = new SERVICE_TRIGGER_INFO();
                serviceTriggerInfo.cTriggers = 1;
                serviceTriggerInfo.pTriggers = pServiceTrigger;
                // Marshal the SERVICE_TRIGGER_INFO struct to native memory
                IntPtr pServiceTriggerInfo = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(
                    SERVICE_TRIGGER_INFO)));
                Marshal.StructureToPtr(serviceTriggerInfo, pServiceTriggerInfo, false);

                // Call ChangeServiceConfig2 with the SERVICE_CONFIG_TRIGGER_INFO level 
                // and pass to it the address of the SERVICE_TRIGGER_INFO structure.
                bool bSuccess = ServiceNative.ChangeServiceConfig2(
                    sc.ServiceHandle.DangerousGetHandle(),
                    ServiceConfig2InfoLevel.SERVICE_CONFIG_TRIGGER_INFO, pServiceTriggerInfo);
                int errorCode = Marshal.GetLastWin32Error();

                // Clean up the native resources
                Marshal.FreeHGlobal(pGuidUSBDevice);
                Marshal.FreeHGlobal(pUSBHardwareId);
                Marshal.FreeHGlobal(pDeviceData);
                Marshal.FreeHGlobal(pServiceTrigger);
                Marshal.FreeHGlobal(pServiceTriggerInfo);

                // If the service failed to be set as trigger start, throw the error 
                // returned by the ChangeServiceConfig2 function.
                if (!bSuccess)
                {
                    Marshal.ThrowExceptionForHR(errorCode);
                }
            }
        }


        /// <summary>
        /// Set the service to trigger-start when the first IP address on the TCP/IP 
        /// networking stack becomes available, and trigger-stop when the last IP address on 
        /// the TCP/IP networking stack becomes unavailable.
        /// </summary>
        /// <param name="serviceName"></param>
        private void SetServiceTriggerStartOnIPAddressArrival(string serviceName)
        {
            using (ServiceController sc = new ServiceController(serviceName))
            {
                // Marshal Guid struct NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID and 
                // NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID to native memory
                IntPtr pGuidIpAddressArrival = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Guid)));
                Marshal.StructureToPtr(NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID,
                    pGuidIpAddressArrival, false);
                IntPtr pGuidIpAddressRemoval = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Guid)));
                Marshal.StructureToPtr(NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID,
                    pGuidIpAddressRemoval, false);

                // Allocate and set the SERVICE_TRIGGER structure for 
                // NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID to start the service
                SERVICE_TRIGGER serviceTrigger1 = new SERVICE_TRIGGER();
                serviceTrigger1.dwTriggerType =
                    ServiceTriggerType.SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY;
                serviceTrigger1.dwAction =
                    ServiceTriggerAction.SERVICE_TRIGGER_ACTION_SERVICE_START;
                serviceTrigger1.pTriggerSubtype = pGuidIpAddressArrival;

                // Allocate and set the SERVICE_TRIGGER structure for 
                // NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID to stop the service
                SERVICE_TRIGGER serviceTrigger2 = new SERVICE_TRIGGER();
                serviceTrigger2.dwTriggerType =
                    ServiceTriggerType.SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY;
                serviceTrigger2.dwAction =
                    ServiceTriggerAction.SERVICE_TRIGGER_ACTION_SERVICE_STOP;
                serviceTrigger2.pTriggerSubtype = pGuidIpAddressRemoval;

                // Marshal the two SERVICE_TRIGGER structs to native memory as an array
                IntPtr pServiceTriggers = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(
                    SERVICE_TRIGGER)) * 2 /*2 elements*/);
                Marshal.StructureToPtr(serviceTrigger1, pServiceTriggers, false);
                Marshal.StructureToPtr(serviceTrigger2, new IntPtr((long)pServiceTriggers +
                    Marshal.SizeOf(typeof(SERVICE_TRIGGER))), false);

                // Allocate and set the SERVICE_TRIGGER_INFO structure
                SERVICE_TRIGGER_INFO serviceTriggerInfo = new SERVICE_TRIGGER_INFO();
                serviceTriggerInfo.cTriggers = 2;
                serviceTriggerInfo.pTriggers = pServiceTriggers;
                // Marshal the SERVICE_TRIGGER_INFO struct to native memory
                IntPtr pServiceTriggerInfo = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(
                    SERVICE_TRIGGER_INFO)));
                Marshal.StructureToPtr(serviceTriggerInfo, pServiceTriggerInfo, false);

                // Call ChangeServiceConfig2 with the SERVICE_CONFIG_TRIGGER_INFO level 
                // and pass to it the address of the SERVICE_TRIGGER_INFO structure.
                bool bSuccess = ServiceNative.ChangeServiceConfig2(
                    sc.ServiceHandle.DangerousGetHandle(),
                    ServiceConfig2InfoLevel.SERVICE_CONFIG_TRIGGER_INFO, pServiceTriggerInfo);
                int errorCode = Marshal.GetLastWin32Error();

                // Clean up the native resources
                Marshal.FreeHGlobal(pGuidIpAddressArrival);
                Marshal.FreeHGlobal(pGuidIpAddressRemoval);
                Marshal.FreeHGlobal(pServiceTriggers);
                Marshal.FreeHGlobal(pServiceTriggerInfo);

                // If the service failed to be set as trigger start, throw the error 
                // returned by the ChangeServiceConfig2 function.
                if (!bSuccess)
                {
                    Marshal.ThrowExceptionForHR(errorCode);
                }
            }
        }
    }
}
